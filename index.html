<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
      //  var coordSystem=function(b){var g=b.normalize();b=0==Math.abs(b.x)&&0==Math.abs(b.y)?(new BABYLON.Vector3(b.z,0,0)).normalize():(new BABYLON.Vector3(b.y,-b.x,0)).normalize();var r=BABYLON.Vector3.Cross(b,g);return{x:b,y:g,z:r}},randPct=function(b,g){return 0==g?b:(1+(1-2*Math.random())*g)*b},createBranch=function(b,g,r,w,h,l,v,n,x){for(var t=[],d,c=[],f,q=[],a=0;12>a;a++)t[a]=[];for(var m=0;m<h;m++)for(a=m/h,d=g.y.scale(a*r),d.addInPlace(g.x.scale(v*Math.exp(-a)*Math.sin(l*a*Math.PI))),d.addInPlace(b),c[m]=d,d=n*(1+(.4*Math.random()-.2))*(1-(1-w)*a),q.push(d),a=0;12>a;a++)f=a*Math.PI/6,f=g.x.scale(d*Math.cos(f)).add(g.z.scale(d*Math.sin(f))),f.addInPlace(c[m]),t[a].push(f);for(a=0;12>a;a++)t[a].push(c[c.length-1]);return{branch:BABYLON.MeshBuilder.CreateRibbon("branch",{pathArray:t,closeArray:!0},x),core:c,_radii:q}},createTreeBase=function(b,g,r,w,h,l,v,n,x,t){var d=2/(1+Math.sqrt(5)),c=new BABYLON.Vector3(0,1,0),f,c=coordSystem(c),q=new BABYLON.Vector3(0,0,0),a=[],m=[],e=[],A=[],q=createBranch(q,c,b,g,r,1,x,1,t);a.push(q.branch);var y=q.core;m.push(y);e.push(q._radii);A.push(c);for(var q=y[y.length-1],y=2*Math.PI/h,z,u,p,C,B=0;B<h;B++)if(f=randPct(B*y,.25),f=c.y.scale(Math.cos(randPct(l,.15))).add(c.x.scale(Math.sin(randPct(l,.15))*Math.sin(f))).add(c.z.scale(Math.sin(randPct(l,.15))*Math.cos(f))),z=coordSystem(f),f=createBranch(q,z,b*v,g,r,n,x*d,g,t),p=f.core,p=p[p.length-1],a.push(f.branch),m.push(f.core),e.push(f._radii),A.push(z),1<w)for(var D=0;D<h;D++)u=randPct(D*y,.25),u=z.y.scale(Math.cos(randPct(l,.15))).add(z.x.scale(Math.sin(randPct(l,.15))*Math.sin(u))).add(z.z.scale(Math.sin(randPct(l,.15))*Math.cos(u))),u=coordSystem(u),C=createBranch(p,u,b*v*v,g,r,n,x*d*d,g*g,t),a.push(C.branch),m.push(C.core),e.push(f._radii),A.push(u);return{tree:BABYLON.Mesh.MergeMeshes(a),paths:m,radii:e,directions:A}},createTree=function(b,g,r,w,h,l,v,n,x,t,d,c,f,q,a,m){1!=h&&2!=h&&(h=1);var e=createTreeBase(b,g,r,h,l,v,n,d,c,m);e.tree.material=w;var A=b*Math.pow(n,h),y=A/(2*f),z=1.5*Math.pow(g,h-1);n=BABYLON.MeshBuilder.CreateDisc("leaf",{radius:z/2,tessellation:12,sideOrientation:BABYLON.Mesh.DOUBLESIDE},m);b=new BABYLON.SolidParticleSystem("leaveSPS",m,{updatable:!1});b.addShape(n,2*f*Math.pow(l,h),{positionFunction:function(b,a,g){a=Math.floor(g/(2*f));1==h?a++:a=2+a%l+Math.floor(a/l)*(l+1);var E=(g%(2*f)*y+3*y/2)/A,d=Math.ceil(r*E);d>e.paths[a].length-1&&(d=e.paths[a].length-1);var k=d-1,c=k/(r-1),m=d/(r-1);b.position=new BABYLON.Vector3(e.paths[a][k].x+(e.paths[a][d].x-e.paths[a][k].x)*(E-c)/(m-c),e.paths[a][k].y+(e.paths[a][d].y-e.paths[a][k].y)*(E-c)/(m-c)+(.6*z/q+e.radii[a][d])*(g%2*2-1),e.paths[a][k].z+(e.paths[a][d].z-e.paths[a][k].z)*(E-c)/(m-c));b.rotation.z=Math.random()*Math.PI/4;b.rotation.y=Math.random()*Math.PI/2;b.rotation.z=Math.random()*Math.PI/4;b.scale.y=1/q}});b=b.buildMesh();b.billboard=!0;n.dispose();d=new BABYLON.SolidParticleSystem("miniSPS",m,{updatable:!1});n=new BABYLON.SolidParticleSystem("minileavesSPS",m,{updatable:!1});var u=[];c=2*Math.PI/l;for(var p=0;p<Math.pow(l,h+1);p++)u.push(randPct(Math.floor(p/Math.pow(l,h))*c,.2));c=function(a,b,d){var c=d%Math.pow(l,h);1==h?c++:c=2+c%l+Math.floor(c/l)*(l+1);var f=e.directions[c],c=new BABYLON.Vector3(e.paths[c][e.paths[c].length-1].x,e.paths[c][e.paths[c].length-1].y,e.paths[c][e.paths[c].length-1].z),k=u[d],k=f.y.scale(Math.cos(randPct(v,0))).add(f.x.scale(Math.sin(randPct(v,0))*Math.sin(k))).add(f.z.scale(Math.sin(randPct(v,0))*Math.cos(k))),f=BABYLON.Vector3.Cross(BABYLON.Axis.Y,k),k=Math.acos(BABYLON.Vector3.Dot(k,BABYLON.Axis.Y)/k.length());a.scale=new BABYLON.Vector3(Math.pow(g,h+1),Math.pow(g,h+1),Math.pow(g,h+1));a.quaternion=BABYLON.Quaternion.RotationAxis(f,k);a.position=c;};for(var C=[],B=[],p=e.paths.length,D=e.paths[0].length,F=0;F<x;F++)C.push(2*Math.PI*Math.random()-Math.PI),B.push([Math.floor(Math.random()*p),Math.floor(Math.random()*(D-1)+1)]);p=function(a,c,b){var d=B[b][0],f=B[b][1],k=e.directions[d];c=new BABYLON.Vector3(e.paths[d][f].x,e.paths[d][f].y,e.paths[d][f].z);c.addInPlace(k.z.scale(e.radii[d][f]/2));b=C[b];k=k.y.scale(Math.cos(randPct(t,0))).add(k.x.scale(Math.sin(randPct(t,0))*Math.sin(b))).add(k.z.scale(Math.sin(randPct(t,0))*Math.cos(b)));b=BABYLON.Vector3.Cross(BABYLON.Axis.Y,k);k=Math.acos(BABYLON.Vector3.Dot(k,BABYLON.Axis.Y)/k.length());a.scale=new BABYLON.Vector3(Math.pow(g,h+1),Math.pow(g,h+1),Math.pow(g,h+1));a.quaternion=BABYLON.Quaternion.RotationAxis(b,k);a.position=c};d.addShape(e.tree,Math.pow(l,h+1),{positionFunction:c});d.addShape(e.tree,x,{positionFunction:p});d=d.buildMesh();d.material=w;n.addShape(b,Math.pow(l,h+1),{positionFunction:c});n.addShape(b,x,{positionFunction:p});w=n.buildMesh();b.dispose();w.material=a;a=BABYLON.MeshBuilder.CreateBox("",{},m);a.isVisible=!1;e.tree.parent=a;d.parent=a;return w.parent=a};

        var createScene = function () {
            var scene = new BABYLON.Scene(engine);
            /*var light = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(0, -1, -0.3), scene);
            var camera = new BABYLON.FreeCamera("Camera", new BABYLON.Vector3(0, 5, -20), scene);
            camera.speed = 0.4;
        
            camera.attachControl(canvas, true);
        
            light.position = new BABYLON.Vector3(20, 60, 30);
        */

            var camera1 = new BABYLON.ArcRotateCamera("camera1", Math.PI / 2, Math.PI / 4, 10, new BABYLON.Vector3(0, -5, 0), scene);
            scene.activeCamera = camera1;
            scene.activeCamera.attachControl(canvas, true);
            camera1.lowerRadiusLimit = 2;
            camera1.upperRadiusLimit = 10;
            camera1.wheelDeltaPercentage = 0.01;

            var light = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(0, -0.5, -1.0), scene);
            light.position = new BABYLON.Vector3(0, 5, 5);


            scene.ambientColor = BABYLON.Color3.FromInts(10, 30, 10);
            scene.clearColor = BABYLON.Color3.FromInts(135, 206, 250);
            scene.gravity = new BABYLON.Vector3(0, -9.8, 0);
        
            // Fog
          //  scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
          //  scene.fogDensity = 0.02;
          //   scene.fogColor = scene.clearColor;

            // Skybox
            var skybox = BABYLON.Mesh.CreateBox("skyBox", 150.0, scene);
            var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skybox", scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.disableLighting = true;
            skybox.material = skyboxMaterial;
            skybox.infiniteDistance = true;

            // GUI
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            var instructions = new BABYLON.GUI.TextBlock();
            instructions.text = "Move w/ WASD keys, B for Samba, look with the mouse";
            instructions.color = "white";
            instructions.fontSize = 16;
            instructions.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT
            instructions.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM
            advancedTexture.addControl(instructions);


            // Invisible borders
            var border0 = BABYLON.Mesh.CreateBox("border0", 1, scene);
            border0.scaling = new BABYLON.Vector3(1, 100, 100);
            border0.position.x = -50.0;
            border0.checkCollisions = true;
            border0.isVisible = false;
        
            var border1 = BABYLON.Mesh.CreateBox("border1", 1, scene);
            border1.scaling = new BABYLON.Vector3(1, 100, 100);
            border1.position.x = 50.0;
            border1.checkCollisions = true;
            border1.isVisible = false;
        
            var border2 = BABYLON.Mesh.CreateBox("border2", 1, scene);
            border2.scaling = new BABYLON.Vector3(100, 100, 1);
            border2.position.z = 50.0;
            border2.checkCollisions = true;
            border2.isVisible = false;
        
            var border3 = BABYLON.Mesh.CreateBox("border3", 1, scene);
            border3.scaling = new BABYLON.Vector3(100, 100, 1);
            border3.position.z = -50.0;
            border3.checkCollisions = true;
            border3.isVisible = false;
        
            // Ground
            var ground = BABYLON.Mesh.CreateGroundFromHeightMap("ground", "textures/c.png", 100, 100, 100, 0, -0.1, scene, false);
            var groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
            groundMaterial.diffuseTexture = new BABYLON.Texture("textures/rock.png", scene);

            groundMaterial.diffuseTexture.uScale = 6;
            groundMaterial.diffuseTexture.vScale = 6;
            groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            groundMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            ground.material = groundMaterial;
            ground.receiveShadows = true;
            //ground.checkCollisions = true;

            // Keyboard events
            var inputMap = {};
            scene.actionManager = new BABYLON.ActionManager(scene);
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
                inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
            }));
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
                inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
            }));

            var animalList = [];
            var distanceMatrix=[];


            ground.onReady = function () {
                ground.optimize(100);
        
                // Shadows
                var shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
        
                // Trees

                //leaf material
                var green = new BABYLON.StandardMaterial("green", scene);
                green.diffuseColor = new BABYLON.Color3(0,1,0);

                //trunk and branch material
                var bark = new BABYLON.StandardMaterial("bark", scene);
                bark.emissiveTexture = new BABYLON.Texture("https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Bark_texture_wood.jpg/800px-Bark_texture_wood.jpg", scene);
                bark.diffuseTexture = new BABYLON.Texture("https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Bark_texture_wood.jpg/800px-Bark_texture_wood.jpg", scene);
                bark.diffuseTexture.uScale = 2.0;//Repeat 5 times on the Vertical Axes
                bark.diffuseTexture.vScale = 2.0;//Repeat 5 times on the Horizontal Axes

                //Tree parameters
                var trunk_height = 10;
                var trunk_taper = 0.5;
                var trunk_slices = 5;
                var boughs = 2; // 1 or 2
                var forks = 4;
                var fork_angle = Math.PI/4;
                var fork_ratio = 2/(1+Math.sqrt(3)); //PHI the golden ratio
                var branch_angle = Math.PI/3;
                var bow_freq = 1;
                var bow_height = 1.5;
                var branches = 5;
                var leaves_on_branch = 5;
                var leaf_wh_ratio = 0.5;


                //Create Trees
                BABYLON.SceneLoader.ImportMesh("", "//www.babylonjs.com/assets/Tree/", "tree.babylon", scene, function (newMeshes) {
                    newMeshes[0].material.opacityTexture = null;
                    newMeshes[0].material.backFaceCulling = false;
                    newMeshes[0].isVisible = false;
                    newMeshes[0].position.y = ground.getHeightAtCoordinates(0, 0); // Getting height from ground object
                    shadowGenerator.getShadowMap().renderList.push(newMeshes[0]);
                    var range = 60;
                    var count = 100;
                    for (var index = 0; index < count; index++) {
                        var newInstance = newMeshes[0].createInstance("i" + index);
                        var x = range / 2 - Math.random() * range;
                        var z = range / 2 - Math.random() * range;
        
                        var y = ground.getHeightAtCoordinates(x, z); // Getting height from ground object
                        newInstance.position = new BABYLON.Vector3(x, y, z);
                        newInstance.rotate(BABYLON.Axis.Y, Math.random() * Math.PI * 2, BABYLON.Space.WORLD);
                        var scale = 0.5 + Math.random() * 2;
                        newInstance.scaling.addInPlace(new BABYLON.Vector3(scale, scale, scale));

                        shadowGenerator.getShadowMap().renderList.push(newInstance);
                    }

                    //SPS Tree Generator
                    for (let i = 0; i <10 ; i++) {
                        var tree = createTree(trunk_height, trunk_taper, trunk_slices, bark, boughs, forks, fork_angle, fork_ratio, branches, branch_angle, bow_freq, bow_height, leaves_on_branch, leaf_wh_ratio, green, scene);
                        var x = range / 2 - Math.random() * range;
                        var z = range / 2 - Math.random() * range;
                        var y = ground.getHeightAtCoordinates(x, z);
                        //TODO:Ağaçları küçült ya da hazırları büyült
                        //tree.scale=new BABYLON.Vector3(0.020, 0.020, 0.020);
                        tree.position=new BABYLON.Vector3(x, y, z) ;
                    }

                    shadowGenerator.getShadowMap().refreshRate = 0; // We need to compute it just once
                    shadowGenerator.usePoissonSampling = true;

                    // Collisions
                   // camera.checkCollisions = true;
                   // camera.applyGravity = true;
                });


                BABYLON.SceneLoader.ImportMesh("Rabbit", "/scenes/", "Rabbit.babylon", scene, function (newMeshes, particleSystems, skeletons) {
                    var rabbit = newMeshes[1];
                    rabbit.scaling = new BABYLON.Vector3(0.015, 0.015, 0.015);
                    rabbit.isVisible = false;
                    animalList.push(new BABYLON.Vector3(0, 0, 0));
                    for (var x = 0; x < 10; x++) {
                        var rabbit_family1=rabbit.clone("rabbit_family"+x);
                        rabbit_family1.isVisible = true;
                        shadowGenerator.getShadowMap().renderList.push(rabbit_family1);
                        rabbit_family1.position.x = Math.random() * 50;
                        rabbit_family1.position.y = -2.1;
                        rabbit_family1.position.z = Math.random() * 50;

                        rabbit_family1.skeleton = rabbit.skeleton.clone("clonedSkeleton1");

                        matrix = BABYLON.Matrix.Translation(20, 276, -30*2);
                        matrix.addToSelf(BABYLON.Matrix.Scaling(.5,.5,.5));
                        idx = rabbit_family1.thinInstanceAdd(matrix);

                        animalList.push(new BABYLON.Vector3(rabbit_family1.position.x, rabbit_family1.position.y, rabbit_family1.position.z));
                    }

                    //TODO: Tavşanlar düzgün dağılmıyor
                    for (let i = 0; i <5; i++) {
                        let sk1 = scene.getNodeByName("rabbit_family"+i).skeleton;
                        scene.beginAnimation(sk1, 0, 73, true, 0.8);
                    }

                   // console.log(animalList.length);
                    //console.log(animalList);

                    for (let i = 0; i < animalList.length; i++) {
                        let tempMatrix = [];

                        for (let j=1; j < animalList.length; j++) {
                            tempMatrix.push(distanceVector(animalList[i].x, animalList[i].y, animalList[i].z, animalList[j].x, animalList[j].y, animalList[j].z));
                        }
                        distanceMatrix.push(tempMatrix);
                    }


                    // camera.checkCollisions = true;
                   // camera.applyGravity = true;
                });

                // Load hero character
                BABYLON.SceneLoader.ImportMesh("", "https://assets.babylonjs.com/meshes/", "HVGirl.glb", scene, function (newMeshes, particleSystems, skeletons, animationGroups) {
                    var hero = newMeshes[0];

                    //Scale the model down
                    hero.scaling.scaleInPlace(0.1);

                    //Lock camera on the character
                    camera1.target = hero;

                    //Hero character variables
                    var heroSpeed = 0.3;
                    var heroSpeedBackwards = 0.01;
                    var heroRotationSpeed = 0.1;

                    var animating = true;

                    const walkAnim = scene.getAnimationGroupByName("Walking");
                    const walkBackAnim = scene.getAnimationGroupByName("WalkingBack");
                    const idleAnim = scene.getAnimationGroupByName("Idle");
                    const sambaAnim = scene.getAnimationGroupByName("Samba");


                    //Rendering loop (executed for everyframe)
                    scene.onBeforeRenderObservable.add(() => {
                        var keydown = false;
                        //Manage the movements of the character (e.g. position, direction)
                        if (inputMap["w"]) {
                            hero.moveWithCollisions(hero.forward.scaleInPlace(heroSpeed));
                            keydown = true;
                        }
                        if (inputMap["s"]) {
                            hero.moveWithCollisions(hero.forward.scaleInPlace(-heroSpeedBackwards));
                            keydown = true;
                        }
                        if (inputMap["a"]) {
                            hero.rotate(BABYLON.Vector3.Up(), -heroRotationSpeed);
                            keydown = true;
                        }
                        if (inputMap["d"]) {
                            hero.rotate(BABYLON.Vector3.Up(), heroRotationSpeed);
                            keydown = true;
                        }
                        if (inputMap["b"]) {
                            keydown = true;
                        }

                        //Manage animations to be played
                        if (keydown) {
                            if (!animating) {
                                animating = true;
                                if (inputMap["s"]) {
                                    //Walk backwards
                                    walkBackAnim.start(true, 1.0, walkBackAnim.from, walkBackAnim.to, false);
                                }
                                else if
                                (inputMap["b"]) {
                                    //Samba!
                                    sambaAnim.start(true, 1.0, sambaAnim.from, sambaAnim.to, false);
                                }
                                else {
                                    //Walk
                                    walkAnim.start(true, 1.0, walkAnim.from, walkAnim.to, false);
                                }
                            }
                        }
                        else {

                            if (animating) {
                                //Default animation is idle when no key is down
                                idleAnim.start(true, 1.0, idleAnim.from, idleAnim.to, false);

                                //Stop all animations besides Idle Anim when no key is down
                                sambaAnim.stop();
                                walkAnim.stop();
                                walkBackAnim.stop();

                                //Ensure animation are played only once per rendering loop
                                animating = false;
                            }
                        }
                    });
                });

              //  console.log(distanceMatrix);

                var button = BABYLON.GUI.Button.CreateSimpleButton("but", "Show path");
                button.width = 0.1;
                button.height = "40px";
                button.color = "white";
                button.background = "green";
                button.top = "-400px";
                button.left = "800px";
                advancedTexture.addControl(button);

                button.onPointerClickObservable.add(function () {

                    //console.log(heldKarpSetup(distanceMatrix, 0));

                    var points = [];
                    var n = 450; // number of points
                    var r = 10; //radius
                    for (let i = 0; i < animalList.length; i++) {
                        //points.push( new BABYLON.Vector3((r + (r/5)*Math.sin(8*i*Math.PI/n))* Math.sin(2*i*Math.PI/n), 1.5, (r + (r/10)*Math.sin(6*i*Math.PI/n)) * Math.cos(2*i*Math.PI/n)));
                        points.push(new BABYLON.Vector3(animalList[i].x, 1.5, animalList[i].z ));
                    }

                    //Draw the curve

                    var track = BABYLON.MeshBuilder.CreateLines('track', {points: points}, scene);
                    track.color = new BABYLON.Color3(1, 0.5, 0.8);
                    track.enableEdgesRendering();
                    track.edgesWidth = 6.0;


                 /*   var spot = new BABYLON.SpotLight("spot", new BABYLON.Vector3(25, 15, -10), new BABYLON.Vector3(-1, -0.8, 1), 15, 1, scene);
                    spot.diffuse = new BABYLON.Color3(1, 1, 1);
                    spot.specular = new BABYLON.Color3(0, 0, 0);
                    spot.intensity = 0.8;

                    var mat = new BABYLON.StandardMaterial("mat1", scene);
                    mat.alpha = 1.0;
                    mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 8.0);
                    mat.backFaceCulling = false;

                    var tube = BABYLON.Mesh.CreateTube("tube", points, 1, 4, null, 0, scene, false, BABYLON.Mesh.FRONTSIDE);
                    tube.material = mat;
                    tube.convertToFlatShadedMesh();*/

                });


            }
            return scene;
        };


        var incumbent1 = Infinity;

        /**
         * setup for held karp
         * returns shortest distance from tour (distance matrix) given start
         */
        function heldKarpSetup(tour, start) {

            // if just two cities, output distance between
            if (tour.length == 2)
                return tour[start][1];
            else {
                // create the first subset to send to main algorithm
                // will be tour - start
                var subset = [];
                for (let i = 0; i < tour.length; i++) {
                    if (i != start)
                        subset.push(i);
                }


                heldKarp(tour, subset,  0);

                console.log(subset);

                return incumbent1;
            }

        }

        /**
         * Iterative held karp dynamically programed
         * could be optimized some
         */
        function heldKarp(tourDist, cities) {

            // for last level of tree, will be the reduced total costs
            // reduced meaning the costs of total paths that cause extra work are not calculated
            var lastSubsets = false;

            // generate subsets of the cities - the start
            // ie. {}, {1}, {2}, {3}, {1,2}, {2,3}, {1,3} for 4 cities
            var allSubsets = generateSubsets(cities);

            // array that holds the subsets for each city
            // ie. [1, {}], [2, {}], [3, {}], [2, {1}], [3, {1}], [1, {2}], [3, {2}],
            //     [1, {3}], [2, {3}], [3, {1, 2}], [1, {2, 3}], [2, {1,3}] for 4 cities
            var subsetCities = [];

            // array that holds the costs to each subsetCity index so cost can be looked up reducing duplicate work
            var subsetCosts = [];

            // loop through all subsets
            for (let i = 0; i < allSubsets.length; i++) {
                // loop through cities remaining after removing start
                for (let j = cities[0]; j <= cities.length; j++) {
                    if (!elementOf(j, allSubsets[i])) {
                        subsetCities.push([j, allSubsets[i]]);

                        // calculating the base subsets [1, {}], [2, {}], [3, {}] for 4 cities
                        if (allSubsets[i].length == 0) {
                            subsetCosts.push(tourDist[i][j]);
                        }
                        // calculating the next base since dont have to loop yet [2, {1}], [3, {1}], [1, {2}], [3, {2}],
                        //     													 [1, {3}], [2, {3}] for 4 cities
                        if (allSubsets[i].length == 1) {
                            subsetCosts.push(tourDist[allSubsets[i][0]][j] + subsetCosts[allSubsets[i] - 1]);
                        }

                        // tricky party here [3, {1, 2}], [1, {2, 3}], [2, {1,3}] for 4 cities... this is where more cities will take lots of time
                        if (allSubsets[i].length > 1) {
                            // holds arrays to get the minimum from ie [3, {1, 2}] must use min value between subset [1, {2}] and [2, {1}] already calculated
                            var toGetMin = [];
                            // loop through specific subset
                            for (let x = 0; x < allSubsets[i].length; x++) {
                                // placeholder array so all elements in subset are accounted for (> 4 cities important here)
                                var test = [];
                                // loop through values in subset to acertain values to take min of
                                for (let y = allSubsets[i].length; y > 0; y--) {

                                    if (allSubsets[i][x] != allSubsets[i][y-1]) {
                                        toGetMin.push(allSubsets[i][x]);
                                        test.push(allSubsets[i][y-1]);

                                        toGetMin.push(test.sort(function(a, b){return a - b}));
                                    }
                                }
                            }
                            // this loop could probably be done a different way to save time as it organizes toGetMin to make next part easier
                            var a = [];
                            for (let x = 1; x < toGetMin.length; x+=2){
                                a.push([toGetMin[x-1], toGetMin[x]]);
                            }

                            // holds the value of the sums from each subset to take the minimum value from
                            var sumsToMin = [];

                            // loop through the organized subset lookups
                            for (let x = 0; x < a.length; x++) {

                                // if checking the last subsets remember the values
                                if (a[x][1].length == cities.length -2){
                                    lastSubsets = true;
                                }
                                else {
                                    lastSubsets = false;
                                }

                                // loop through the subsets the need to be looked up
                                // only aplicatble when values are > 2 ... ie for subset [1, {2,3,4}] {2,3,4} > 2 values
                                for (let z = 0; z < a[x][1].length; z++) {
                                    // what subset to add to what distance lookup before taking minimum
                                    // 		ie for 4 cities subset [3, {1, 2}] = distMatrix[1][3] + lookup value for [1, {2}]
                                    // 		then next loop of x = distMatrix[2][3] + lookup value for [2, {1}]
                                    if (a[x][1].length == 1) {
                                        sumsToMin.push(subsetCosts[searchForCost(a[x], subsetCities)] + tourDist[a[x][z]][j]);
                                    }
                                    else {
                                        sumsToMin.push(subsetCosts[searchForCost(a[x], subsetCities)] + tourDist[a[x][1][z]][j]);
                                    }
                                }
                            }

                            // take min of the sums of each subset
                            cost = min(sumsToMin);
                            // push to subsetCities cost placeholder
                            subsetCosts.push(cost);

                            // if last subsets then compare total costs to determine minimum
                            if (cost < incumbent1 && lastSubsets) {
                                incumbent1 = cost;
                            }
                        }
                    }
                }
            }

            console.log(subsetCities);
            console.log(subsetCosts);
            return incumbent1;
        }

        /**
         * returns subsets of array
         * used code from Angelos Chalaris - StackOverflow.com
         */
        function generateSubsets(array) {
            var result = [];
            result.push([]);

            for (var i = 1; i < (1 << array.length ); i++) {
                var subset = [];
                for (var j = 0; j < array.length ; j++)
                    if (i & (1 << j))
                        subset.push(array[j]);

                result.push(subset);
            }

            // pop the last subset that would be used for going back to start since directions say
            // not to include returning to start
            result.pop();
            // probably better to do this in the looping above but this was easiest for me and works the same

            return result;
        }

        /**
         * return the element for cost of subset in subsetcities
         * return -1 if subset does not exist
         */
        function searchForCost(subset, subsetCities) {
            for (let i = 0; i < subsetCities.length; i++) {
                if (JSON.stringify(subset)==JSON.stringify(subsetCities[i]))
                    return i;
            }

            return -1;
        }

        /**
         * returns true if a is an element of b
         * false otherwise
         */
        function elementOf(a, b) {
            for (let i = 0; i < b.length; i++){
                if (a == b[i])
                    return true;
            }

            return false;
        }

        /**
         * returns the minimum value in arr
         */
        function min(arr) {
            var min = Infinity;

            for (let i =0; i< arr.length; i++) {
                if (arr[i] < min)
                    min = arr[i];
            }

            return min;
        }

        function distanceVector( x1,y1,z1, x2,y2,z2 )
        {
            var dx = x1 - x2;
            var dy = y1 - y2;
            var dz = z1 - z2;

            return Math.sqrt( dx * dx + dy * dy + dz * dz );
        }

        window.initFunction = async function() {
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene        
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
